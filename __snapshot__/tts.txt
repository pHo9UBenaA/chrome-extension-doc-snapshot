
  
  
  
  
  

  
    
    
    
  
  
    
    
    
      
  
    
        Home
      
  
  
    
  
  
  
    
      
      
    
    
    
      
  
    
        Docs
      
  
  
    
  
  
  
    
      
      
    
    
    
      
  
    
        Chrome Extensions
      
  
  
    
  
  
  
    
      
      
    
    
    
      
  
    
        Reference
      
  
  
    
  
  
  
    
      
      
    
    
    
      
  
    
        API
      
  
  
    
  
  

    
      
    
    
  
    
  
  
    
      chrome.tts
      
    
  

    
    

    
      
      Stay organized with collections
    
    
      
      Save and categorize content based on your preferences.
    
  
  
  

  
  
  
    
  

  








  
    
.dcc-reference{--color-hairline: #dadce0;--color-blue-lightest: rgba(232, 240, 254, 0.4);--color-blue-lighter: #d2e3fc;--color-blue-medium: #1967d2;--color-blue-darkest: #174ea6;--rgb-blue-darkest: 23, 78, 166;--color-yellow-lightest: rgba(254, 247, 224, 0.3);--color-yellow-lighter: #feefc3;--color-yellow-medium: #f29900;--color-yellow-darkest: #de7100;--rgb-yellow-darkest: 227, 117, 0;--color-red-lightest: rgba(252, 232, 230, 0.4);--color-red-lighter: rgba(252, 232, 230, 0.5);--color-red-medium: #c5221f;--color-red-darkest: #9f0e0e;--rgb-red-darkest: 165, 14, 14;--color-green-lightest: rgba(230, 244, 234, 0.4);--color-green-lighter: #ceead6;--color-green-medium: #188038;--color-green-darkest: #0d652d;--rgb-green-darkest: 13, 101, 45;--color-purple-lightest: rgba(243, 232, 253, 0.4);--color-purple-lighter: rgba(243, 232, 253, 0.5);--color-purple-medium: #8430ce;--color-purple-darkest: #681da8;--rgb-purple-darkest: 104, 29, 168;--color-pink-lightest: rgba(253, 231, 243, 0.4);--color-pink-lighter: rgba(253, 231, 243, 0.5);--color-pink-medium: #d01884;--color-pink-darkest: #9c166b;--rgb-pink-darkest: 156, 22, 107}.dcc-type--label{font-weight:500;font-size:.75rem;line-height:1.3333333333}.dcc-type--xsmall{font-size:.75rem;line-height:1.6666666667}h2.dcc-api-title{display:none}.dcc-code-sections ul{padding-left:0}.dcc-code-sections .dcc-code-sections{border:1px solid var(--color-hairline);padding:calc(1rem - 1px)}.dcc-code-sections .dcc-code-sections ul>li:first-child{border-top:0;padding-top:0}.dcc-code-sections .dcc-code-sections devsite-code{margin-left:calc(-1rem + 1px);margin-right:calc(-1rem + 1px)}.dcc-code-sections .dcc-type--small{font-size:.875em;line-height:2em}.dcc-code-sections__label{font-size:.875rem;line-height:2}.dcc-code-sections__type>:not(:last-child){margin-right:.5ch}.dcc-code-sections__enum{margin-bottom:1rem}.dcc-code-sections__icon::before{background:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTcuNzc2MzkgMS41NTI3OUM3LjkxNzE2IDEuNDgyNCA4LjA4Mjg0IDEuNDgyNCA4LjIyMzYxIDEuNTUyNzlMMTQuMjIzNiA0LjU1Mjc5QzE0LjM5MyA0LjYzNzQ4IDE0LjUgNC44MTA2MSAxNC41IDVWMTFDMTQuNSAxMS4xODk0IDE0LjM5MyAxMS4zNjI1IDE0LjIyMzYgMTEuNDQ3Mkw4LjIyMzYxIDE0LjQ0NzJDOC4wODI4NCAxNC41MTc2IDcuOTE3MTYgMTQuNTE3NiA3Ljc3NjM5IDE0LjQ0NzJMMS43NzYzOSAxMS40NDcyQzEuNjA3IDExLjM2MjUgMS41IDExLjE4OTQgMS41IDExVjVDMS41IDQuODEwNjEgMS42MDcgNC42Mzc0OCAxLjc3NjM5IDQuNTUyNzlMNy43NzYzOSAxLjU1Mjc5Wk0yLjUgNS44MDkwMlYxMC42OTFMNy41IDEzLjE5MVY4LjMwOTAyTDIuNSA1LjgwOTAyWk04LjUgOC4zMDkwMlYxMy4xOTFMMTMuNSAxMC42OTFWNS44MDkwMkw4LjUgOC4zMDkwMlpNMTIuODgyIDVMOCA3LjQ0MDk4TDMuMTE4MDMgNUw4IDIuNTU5MDJMMTIuODgyIDVaIiBmaWxsPSIjNUY2MzY4Ii8+Cjwvc3ZnPgo=") center/contain no-repeat;content:"";display:inline-block;height:1.25em;margin-right:.5ch;vertical-align:middle;width:1.25em}.dcc-code-sections__icon.dcc-code-sections__icon--number::before{background-image:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNiAyLjVINFY0LjVINlYyLjVaIiBmaWxsPSIjNUY2MzY4Ii8+CjxwYXRoIGQ9Ik02IDUuNUg0VjcuNUg2VjUuNVoiIGZpbGw9IiM1RjYzNjgiLz4KPHBhdGggZD0iTTQgOC41SDZWMTAuNUg0VjguNVoiIGZpbGw9IiM1RjYzNjgiLz4KPHBhdGggZD0iTTkgMi41SDdWNC41SDlWMi41WiIgZmlsbD0iIzVGNjM2OCIvPgo8cGF0aCBkPSJNNyA1LjVIOVY3LjVIN1Y1LjVaIiBmaWxsPSIjNUY2MzY4Ii8+CjxwYXRoIGQ9Ik05IDguNUg3VjEwLjVIOVY4LjVaIiBmaWxsPSIjNUY2MzY4Ii8+CjxwYXRoIGQ9Ik03IDExLjVIOVYxMy41SDdWMTEuNVoiIGZpbGw9IiM1RjYzNjgiLz4KPHBhdGggZD0iTTEyIDIuNUgxMFY0LjVIMTJWMi41WiIgZmlsbD0iIzVGNjM2OCIvPgo8cGF0aCBkPSJNMTAgNS41SDEyVjcuNUgxMFY1LjVaIiBmaWxsPSIjNUY2MzY4Ii8+CjxwYXRoIGQ9Ik0xMiA4LjVIMTBWMTAuNUgxMlY4LjVaIiBmaWxsPSIjNUY2MzY4Ii8+Cjwvc3ZnPgo=")}.dcc-code-sections__icon.dcc-code-sections__icon--string::before{background-image:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNC43MTQyOSAxMkg1Ljg1NzE0TDcuMjg1NzEgOC4yODU3MVY0LjVDNy4yODU3MSA0LjIyMzg2IDcuMDYxODYgNCA2Ljc4NTcxIDRIMy41QzMuMjIzODYgNCAzIDQuMjIzODYgMyA0LjVWNy43ODU3MUMzIDguMDYxODYgMy4yMjM4NiA4LjI4NTcxIDMuNSA4LjI4NTcxSDYuMTQyODZMNC43MTQyOSAxMlpNMTAuNDI4NiAxMkgxMS41NzE0TDEzIDguMjg1NzFWNC41QzEzIDQuMjIzODYgMTIuNzc2MSA0IDEyLjUgNEg5LjIxNDI5QzguOTM4MTQgNCA4LjcxNDI5IDQuMjIzODYgOC43MTQyOSA0LjVWNy43ODU3MUM4LjcxNDI5IDguMDYxODYgOC45MzgxNCA4LjI4NTcxIDkuMjE0MjkgOC4yODU3MUgxMS44NTcxTDEwLjQyODYgMTJaIiBmaWxsPSIjNUY2MzY4Ii8+Cjwvc3ZnPgo=")}.dcc-code-sections__icon.dcc-code-sections__icon--boolean::before{background-image:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMTIuMzUzNiA1Ljg1MzU1TDExLjY0NjQgNS4xNDY0NUw3IDkuNzkyODlMNC44NTM1NSA3LjY0NjQ1TDQuMTQ2NDUgOC4zNTM1NUw3IDExLjIwNzFMMTIuMzUzNiA1Ljg1MzU1WiIgZmlsbD0iIzVGNjM2OCIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIgM0MyIDIuNDQ3NzIgMi40NDc3MiAyIDMgMkgxM0MxMy41NTIzIDIgMTQgMi40NDc3MiAxNCAzVjEzQzE0IDEzLjU1MjMgMTMuNTUyMyAxNCAxMyAxNEgzQzIuNDQ3NzIgMTQgMiAxMy41NTIzIDIgMTNWM1pNMyAzSDEzVjEzSDNMMyAzWiIgZmlsbD0iIzVGNjM2OCIvPgo8L3N2Zz4K")}.dcc-code-sections__icon.dcc-code-sections__icon--function::before{background-image:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMuNSA0QzMuNSAyLjYxOTI5IDQuNjE5MjkgMS41IDYgMS41SDYuNVYyLjVINkM1LjE3MTU3IDIuNSA0LjUgMy4xNzE1NyA0LjUgNFY1Ljc2MzkzQzQuNSA2LjcxMDg2IDMuOTY0OTkgNy41NzY1MiAzLjExODAzIDhDMy45NjQ5OSA4LjQyMzQ4IDQuNSA5LjI4OTE0IDQuNSAxMC4yMzYxVjEyQzQuNSAxMi44Mjg0IDUuMTcxNTcgMTMuNSA2IDEzLjVINi41VjE0LjVINkM0LjYxOTI5IDE0LjUgMy41IDEzLjM4MDcgMy41IDEyVjEwLjIzNjFDMy41IDkuNjY3OTEgMy4xNzkgOS4xNDg1MiAyLjY3MDgyIDguODk0NDNMMS43NzYzOSA4LjQ0NzIxQzEuNjA3IDguMzYyNTIgMS41IDguMTg5MzkgMS41IDhDMS41IDcuODEwNjEgMS42MDcgNy42Mzc0OCAxLjc3NjM5IDcuNTUyNzlMMi42NzA4MiA3LjEwNTU3QzMuMTc5IDYuODUxNDggMy41IDYuMzMyMDkgMy41IDUuNzYzOTNWNFpNMTAgMi41SDkuNVYxLjVIMTBDMTEuMzgwNyAxLjUgMTIuNSAyLjYxOTI5IDEyLjUgNFY1Ljc2MzkzQzEyLjUgNi4zMzIwOSAxMi44MjEgNi44NTE0OCAxMy4zMjkyIDcuMTA1NTdMMTQuMjIzNiA3LjU1Mjc5QzE0LjM5MyA3LjYzNzQ4IDE0LjUgNy44MTA2MSAxNC41IDhDMTQuNSA4LjE4OTM5IDE0LjM5MyA4LjM2MjUyIDE0LjIyMzYgOC40NDcyMUwxMy4zMjkyIDguODk0NDNDMTIuODIxIDkuMTQ4NTIgMTIuNSA5LjY2NzkxIDEyLjUgMTAuMjM2MVYxMkMxMi41IDEzLjM4MDcgMTEuMzgwNyAxNC41IDEwIDE0LjVIOS41VjEzLjVIMTBDMTAuODI4NCAxMy41IDExLjUgMTIuODI4NCAxMS41IDEyVjEwLjIzNjFDMTEuNSA5LjI4OTE0IDEyLjAzNSA4LjQyMzQ4IDEyLjg4MiA4QzEyLjAzNSA3LjU3NjUyIDExLjUgNi43MTA4NiAxMS41IDUuNzYzOTNWNEMxMS41IDMuMTcxNTcgMTAuODI4NCAyLjUgMTAgMi41WiIgZmlsbD0iIzVGNjM2OCIvPgo8L3N2Zz4K")}.dcc-code-sections__icon.dcc-code-sections__icon--array::before{background-image:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyIDYuNUg0VjkuNUgxMlY2LjVaTTEyIDUuNUg0VjNIMTJWNS41Wk0xMyAzQzEzIDIuNDQ3NzIgMTIuNTUyMyAyIDEyIDJINEMzLjQ0NzcyIDIgMyAyLjQ0NzcyIDMgM1YxM0MzIDEzLjU1MjMgMy40NDc3MiAxNCA0IDE0SDEyQzEyLjU1MjMgMTQgMTMgMTMuNTUyMyAxMyAxM1YzWk0xMiAxMC41SDRWMTNIMTJWMTAuNVoiIGZpbGw9IiM1RjYzNjgiLz4KPC9zdmc+Cg==")}.dcc-code-sections__icon.dcc-code-sections__icon--reference::before{background-image:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMyAySDhWM0gzTDMgMTNIMTNWOEgxNFYxM0MxNCAxMy41NTIzIDEzLjU1MjMgMTQgMTMgMTRIM0MyLjQ0NzcyIDE0IDIgMTMuNTUyMyAyIDEzVjNDMiAyLjQ0NzcyIDIuNDQ3NzIgMiAzIDJaIiBmaWxsPSIjNUY2MzY4Ii8+CjxwYXRoIGQ9Ik05LjUgM0gxMi4yOTI5TDUuNjQ2NDUgOS42NDY0NUw2LjM1MzU1IDEwLjM1MzZMMTMgMy43MDcxMVY2LjVIMTRWMkg5LjVWM1oiIGZpbGw9IiM1RjYzNjgiLz4KPC9zdmc+Cg==")}.dcc-code-sections__optional{color:var(--color-pink-medium)}.dcc-code-sections__value{color:var(--color-code-number)}.dcc-code-sections__deprecated{color:var(--color-red-medium)}.dcc-code-sections__callback{display:block}p>.dcc-code-sections__callback{margin-top:.5em}.dcc-code-sections__overline{border-top:1px solid var(--color-hairline);margin:1em 0;padding-top:get-size(300)}.dcc-code-sections__mode{color:var(--color-code-comment);text-transform:uppercase}.dcc-code-sections li{border-top:1px solid var(--color-hairline);display:flex;flex-direction:column;padding-top:get-size(300);position:relative}.dcc-code-sections li>:first-child{font-weight:500;flex:0 0 auto;flex-shrink:1;min-width:9rem;padding-right:1rem}.dcc-code-sections li>:not(:first-child){flex-grow:1}.dcc-code-sections--summary{padding-left:0}.dcc-code-sections--summary>li:first-child{border-top:0;padding-top:0}@media(min-width: 992px){.dcc-code-sections--summary>li{flex-direction:row}}.dcc-code-sections--summary>li>:first-child{min-width:6.5rem}.dcc-tag-pill{--flow-space: 0.25rem;box-sizing:border-box;border-radius:.75rem;font-weight:500;font-size:.75rem;line-height:1.3333333333;margin:calc(var(--flow-space)/2);background-color:var(--color-blue-lightest);color:var(--color-blue-darkest);margin-bottom:.5rem;padding:.25rem .75rem;cursor:help}.dcc-tag-pill--blue{background-color:var(--color-blue-lightest);color:var(--color-blue-darkest)}.dcc-tag-pill--yellow{background-color:var(--color-yellow-lightest);color:var(--color-yellow-darkest)}.dcc-tag-pill--red{background-color:var(--color-red-lightest);color:var(--color-red-darkest)}.dcc-tag-pill--green{background-color:var(--color-green-lightest);color:var(--color-green-darkest)}.dcc-tag-pill--pink{background-color:var(--color-pink-lightest);color:var(--color-pink-darkest)}.dcc-tag-pill--purple{background-color:var(--color-purple-lightest);color:var(--color-purple-darkest)}a>.dcc-tag-pill{cursor:pointer}






Description
Use the chrome.tts API to play synthesized text-to-speech (TTS). See also the related ttsEngine API, which allows an extension to implement a speech engine.

Chrome provides this capability on Windows (using SAPI 5), Mac OS X, and ChromeOS, using
speech synthesis capabilities provided by the operating system. On all platforms, the user can
install extensions that register themselves as alternative speech engines.

Permissions
tts





Concepts and usage

Generate speech

Call speak() from your extension to speak. For example:
chrome.tts.speak('Hello, world.');

To stop speaking immediately, just call stop():
chrome.tts.stop();

You can provide options that control various properties of the speech, such as its rate, pitch, and
more. For example:
chrome.tts.speak('Hello, world.', {'rate': 2.0});

It's also a good idea to specify the language so that a synthesizer supporting that language (and
regional dialect, if applicable) is chosen.
chrome.tts.speak('Hello, world.', {'lang': 'en-US', 'rate': 2.0});

By default, each call to speak() interrupts any ongoing speech and speaks immediately. To
determine if a call would be interrupting anything, you can call isSpeaking(). In addition, you
can use the enqueue option to cause this utterance to be added to a queue of utterances that will
be spoken when the current utterance has finished.
chrome.tts.speak('Speak this first.');
chrome.tts.speak(
    'Speak this next, when the first sentence is done.', {'enqueue': true});

A complete description of all options can be found under tts.speak(). Not all speech
engines will support all options.

To catch errors and make sure you're calling speak() correctly, pass a callback function that
takes no arguments. Inside the callback, check runtime.lastError to see if there were any
errors.
chrome.tts.speak(
  utterance,
  options,
  function() {
    if (chrome.runtime.lastError) {
      console.log('Error: ' + chrome.runtime.lastError.message);
    }
  }
);

The callback returns right away, before the engine has started generating speech. The purpose of the
callback is to alert you to syntax errors in your use of the TTS API, not to catch all possible
errors that might occur in the process of synthesizing and outputting speech. To catch these errors
too, you need to use an event listener, described in the next section.

Listen to events

To get more real-time information about the status of synthesized speech, pass an event listener in
the options to speak(), like this:
chrome.tts.speak(
  utterance,
  {
    onEvent: function(event) {
      console.log('Event ' + event.type + ' at position ' + event.charIndex);
      if (event.type == 'error') {
        console.log('Error: ' + event.errorMessage);
      }
    }
  },
  callback
);

Each event includes an event type, the character index of the current speech relative to the
utterance, and for error events, an optional error message. The event types are:


'start': The engine has started speaking the utterance.
'word': A word boundary was reached. Use event.charIndex to determine the current speech
position.
'sentence': A sentence boundary was reached. Use event.charIndex to determine the current
speech position.
'marker': An SSML marker was reached. Use event.charIndex to determine the current speech
position.
'end': The engine has finished speaking the utterance.
'interrupted': This utterance was interrupted by another call to speak() or stop() and did
not finish.
'cancelled': This utterance was queued, but then cancelled by another call to speak() or
stop() and never began to speak at all.
'error': An engine-specific error occurred and this utterance cannot be spoken. Check
event.errorMessage for details.


Four of the event types—'end', 'interrupted', 'cancelled', and 'error'—are final. After
one of those events is received, this utterance will no longer speak and no new events from this
utterance will be received.

Some voices may not support all event types, and some voices may not send any events at all. If you
don't want to use a voice unless it sends certain events, pass the events you require in the
requiredEventTypes member of the options object, or use getVoices() to choose a voice that meets
your requirements. Both are described in what follows.

SSML markup

Utterances used in this API may include markup using the Speech Synthesis Markup Language
(SSML). If you use SSML, the first argument to speak() should be a complete SSML document with
an XML header and a top-level <speak> tag, not a document fragment.

For example:
chrome.tts.speak(
  '<?xml version="1.0"?>' +
  '<speak>' +
  '  The <emphasis>second</emphasis> ' +
  '  word of this sentence was emphasized.' +
  '</speak>'
);

Not all speech engines will support all SSML tags, and some may not support SSML at all, but all
engines are required to ignore any SSML they don't support and to still speak the underlying text.

Choose a voice

By default, Chrome chooses the most appropriate voice for each utterance you want to speak, based on
the language. On most Windows, Mac OS X, and ChromeOS systems, speech synthesis provided by the
operating system should be able to speak any text in at least one language. Some users may have a
variety of voices available, though, from their operating system and from speech engines implemented
by other Chrome extensions. In those cases, you can implement custom code to choose the appropriate
voice, or to present the user with a list of choices.

To get a list of all voices, call getVoices() and pass it a function that receives an array of
TtsVoice objects as its argument:
chrome.tts.getVoices(
  function(voices) {
    for (var i = 0; i < voices.length; i++) {
      console.log('Voice ' + i + ':');
      console.log('  name: ' + voices[i].voiceName);
      console.log('  lang: ' + voices[i].lang);
      console.log('  extension id: ' + voices[i].extensionId);
      console.log('  event types: ' + voices[i].eventTypes);
    }
  }
);

Types
  
    
      EventType
    
      Chrome 54+
      
    Enum
      "start"  "end"  "word"  "sentence"  "marker"  "interrupted"  "cancelled"  "error"  "pause"  "resume"  
    
  
    
      TtsEvent
    An event from the TTS engine to communicate the status of an utterance.
Properties
    
      charIndex
      number optional
    The index of the current character in the utterance. For word events, the event fires at the end of one word and before the beginning of the next. The charIndex represents a point in the text at the beginning of the next word to be spoken.

    
      errorMessage
      string optional
    The error description, if the event type is error.

    
      length
      number optional
    
      Chrome 74+
      
    The length of the next part of the utterance. For example, in a word event, this is the length of the word which will be spoken next. It will be set to -1 if not set by the speech engine.

    
      type
      EventType
    The type can be start as soon as speech has started, word when a word boundary is reached, sentence when a sentence boundary is reached, marker when an SSML mark element is reached, end when the end of the utterance is reached, interrupted when the utterance is stopped or interrupted before reaching the end, cancelled when it's removed from the queue before ever being synthesized, or error when any other error occurs. When pausing speech, a pause event is fired if a particular utterance is paused in the middle, and resume if an utterance resumes speech. Note that pause and resume events may not fire if speech is paused in-between utterances.

    
    
      TtsOptions
    
      Chrome 77+
      
    The speech options for the TTS engine.
Properties
    
      desiredEventTypes
      string[] optional
    The TTS event types that you are interested in listening to. If missing, all event types may be sent.

    
      enqueue
      boolean optional
    If true, enqueues this utterance if TTS is already in progress. If false (the default), interrupts any current speech and flushes the speech queue before speaking this new utterance.

    
      extensionId
      string optional
    The extension ID of the speech engine to use, if known.

    
      gender
      VoiceGender optional
    
      
        Deprecated since Chrome 77
    Gender is deprecated and will be ignored.Gender of voice for synthesized speech.

    
      lang
      string optional
    The language to be used for synthesis, in the form language-region. Examples: 'en', 'en-US', 'en-GB', 'zh-CN'.

    
      pitch
      number optional
    Speaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being highest. 1.0 corresponds to a voice's default pitch.

    
      rate
      number optional
    Speaking rate relative to the default rate for this voice. 1.0 is the default rate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and 0.5 is half as fast. Values below 0.1 or above 10.0 are strictly disallowed, but many voices will constrain the minimum and maximum rates further—for example a particular voice may not actually speak faster than 3 times normal even if you specify a value larger than 3.0.

    
      requiredEventTypes
      string[] optional
    The TTS event types the voice must support.

    
      voiceName
      string optional
    The name of the voice to use for synthesis. If empty, uses any available voice.

    
      volume
      number optional
    Speaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 1.0.

    
      onEvent
      void optional
    This function is called with events that occur in the process of speaking the utterance.

          The onEvent function looks like:
          (event: TtsEvent) => {...}
        
    
      event
      TtsEvent
    The update event from the text-to-speech engine indicating the status of this utterance.

    
    
    
      TtsVoice
    A description of a voice available for speech synthesis.
Properties
    
      eventTypes
      EventType[] optional
    All of the callback event types that this voice is capable of sending.

    
      extensionId
      string optional
    The ID of the extension providing this voice.

    
      gender
      VoiceGender optional
    
      
        Deprecated since Chrome 70
    Gender is deprecated and will be ignored.This voice's gender.

    
      lang
      string optional
    The language that this voice supports, in the form language-region. Examples: 'en', 'en-US', 'en-GB', 'zh-CN'.

    
      remote
      boolean optional
    If true, the synthesis engine is a remote network resource. It may be higher latency and may incur bandwidth costs.

    
      voiceName
      string optional
    The name of the voice.

    
    
      VoiceGender
    
      Chrome 54+
      
        Deprecated since Chrome 70
    Gender is deprecated and is ignored.Enum
      "male"  "female"  
    
  Methods
  
    
      getVoices()
    
      
        Promise
      
    
        chrome.tts.getVoices(  callback?: function,)
      Gets an array of all available voices.
Parameters
    
      callback
      function optional
    
          The callback parameter looks like:
          (voices: TtsVoice[]) => void
        
    
      voices
      TtsVoice[]
    Array of tts.TtsVoice objects representing the available voices for speech synthesis.

    
    Returns
          
            Promise<TtsVoice[]>
            
      Chrome 101+
      
    
              
                Promises are supported in Manifest V3 and later, but callbacks are provided for
                backward compatibility. You cannot use both on the same function call. The
                promise resolves with the same type that is passed to the callback.
              
            
        
      
    
      isSpeaking()
    
      
        Promise
      
    
        chrome.tts.isSpeaking(  callback?: function,)
      Checks whether the engine is currently speaking. On Mac OS X, the result is true whenever the system speech engine is speaking, even if the speech wasn't initiated by Chrome.
Parameters
    
      callback
      function optional
    
          The callback parameter looks like:
          (speaking: boolean) => void
        
    
      speaking
      boolean
    True if speaking, false otherwise.

    
    Returns
          
            Promise<boolean>
            
      Chrome 101+
      
    
              
                Promises are supported in Manifest V3 and later, but callbacks are provided for
                backward compatibility. You cannot use both on the same function call. The
                promise resolves with the same type that is passed to the callback.
              
            
        
      
    
      pause()
    
        chrome.tts.pause()
      Pauses speech synthesis, potentially in the middle of an utterance. A call to resume or stop will un-pause speech.

    
      resume()
    
        chrome.tts.resume()
      If speech was paused, resumes speaking where it left off.

    
      speak()
    
      
        Promise
      
    
        chrome.tts.speak(  utterance: string,  options?: TtsOptions,  callback?: function,)
      Speaks text using a text-to-speech engine.
Parameters
    
      utterance
      string
    The text to speak, either plain text or a complete, well-formed SSML document. Speech engines that do not support SSML will strip away the tags and speak the text. The maximum length of the text is 32,768 characters.

    
      options
      TtsOptions optional
    The speech options.

    
      callback
      function optional
    
          The callback parameter looks like:
          () => void
        
    Returns
          
            Promise<void>
            
      Chrome 101+
      
    
              
                Promises are supported in Manifest V3 and later, but callbacks are provided for
                backward compatibility. You cannot use both on the same function call. The
                promise resolves with the same type that is passed to the callback.
              
            
        
      
    
      stop()
    
        chrome.tts.stop()
      Stops any current speech and flushes the queue of any pending utterances. In addition, if speech was paused, it will now be un-paused for the next call to speak.
Events
  
    
      onVoicesChanged
    
      Chrome 124+
      
    
        chrome.tts.onVoicesChanged.addListener(  callback: function,)
      Called when the list of tts.TtsVoice that would be returned by getVoices has changed.
Parameters
    
      callback
      function
    
          The callback parameter looks like:
          () => void
        
    

  

  


  

  
    
    
      
    
    
  
       
    
    
  

  
  
  
  

